with DCF77_Low_Level;
with DCF77_Types;
use  DCF77_Types;

package DCF77_Bitlayer is

	type Bitlayer is tagged limited private;

	procedure Init(Ctx: in out Bitlayer; LL: in DCF77_Low_Level.LLP);
	function Update_Tick(Ctx: in out Bitlayer) return Reading;

	function Get_Unidentified(Ctx: in Bitlayer) return Natural;
	function Get_Overflown(Ctx: in Bitlayer) return Natural;
	function Get_Delay(Ctx: in Bitlayer) return DCF77_Low_Level.Time;
	function Get_Counter(Ctx: in Bitlayer) return Natural;
	function Get_State(Ctx: in Bitlayer) return String;
	function Get_Input(Ctx: in Bitlayer) return String;
	procedure Draw_Bits_State(Ctx: in Bitlayer; L1, L2: in out String)
			with Pre => (L1'First = 1 and L1'Length >= 16 and
					L2'First = 1 and L2'Length >= 16);
	procedure Draw_Bits_Oszi(Ctx: in Bitlayer; L1, L2: in out String)
			with Pre => (L1'First = 1 and L1'Length >= 16 and
					L2'First = 1 and L2'Length >= 16);

private

	Second_In_Us:    constant DCF77_Low_Level.Time := 1_000_000;
	Delay_Us_Target: constant DCF77_Low_Level.Time :=   100_000;

	-- States
	-- ------
	type State is (
		-- “all zero so far” or invalid (short spikes) signals
		S_Z0, S_Z1, S_Z2, S_Z3, S_Z4, S_Z5, S_Z6, S_Z7, S_Z8, S_Z9,

		-- “decode signal for output” states. An even suffix
		-- means this looks like a Bit_0 so far, an odd suffix
		-- means this looks like a Bit_1 so far. Ultimately the
		-- meaning of the signal is decided upon request to A_Decode.
		S_O10, S_O11, S_O20, S_O21, S_O30, S_O31, S_O40, S_O41,
		S_O50, S_O51, S_O60, S_O61, S_O70, S_O71, S_O80, S_O81,
		S_O90, S_O91, S_O00, S_O01,

		-- “wait” states aka. “quiet zones” where any input
		-- is ignored and time is just passing. This is used to model
		-- phase locking.
		S_W2, S_W3, S_W4, S_W5, S_W6, S_W7, S_W8
	);

	-- Inputs
	-- ------
	--
	-- In general, inputs are considered clean if at most one bit at the
	-- beginning or end mismatches the expected reading for the signal type.
	-- Other filters could likely be devised without having to change this
	-- categorization here.
	--
	-- In order to decide which state to take in the state machine, the most
	-- specific input type is applied which is modelled by the order of
	-- the inputs here I_1 is most specific and I_ANY_OTHER is least
	-- specific (last option to find next state to go to).
	type Input is (
		I_1,         -- 1-like signal: 1..1, 1..10, 01..1
		I_X1,        -- 1-like signal with any prefix
		             -- (1..1, 0..01..1, 0..01..10, 0..1)
		I_0,         -- 0-like signal: 0..0, 10..0, 0..01
		I_X0,        -- 0-like signal with any prefix
		             -- (1..10..0, 10..0, 0..0)
		I_ANY_OTHER  -- any other signal
	);

	-- Actions, Action Results and Transitions
	-- ---------------------------------------
	--
	-- {skip, append, decode} x {fail silently, fail loudly}
	--
	-- Actions decide about what is done with the input signal, what outputs
	-- are generated by the Bitlayer and which state is chosen next.
	--
	-- The basic definition is as follows:
	--
	-- Action  Process Input?    Generate Output!   Goto State
	-- ------  ----------------  -----------------  -----------------------
	-- Ignore  input ignored     always error       as specified in default
	--         clear buffer
	-- Append  append to buffer  error if invalid   R_Default  on error
	--                                              R_0        on OK
	-- Decode  including buffer  error if invalid   R_Default  on error
	--         clear buffer      R_0/R_1 otherwise  R_0 or R_1 on OK
	--
	-- The operation to perform on error is defined by an additional
	-- reading (`G`) supplied alongside the transition. It is either
	-- No_Update to not output anything or No_Signal to progress in the
	-- second counter.
	type Action        is (A_Ignore, A_Append, A_Decode);
	type Action_Result is (R_Default, R_0, R_1);
	type Target_Choice is array (Action_Result) of State;
	type Transition is record
		A: Action;
		G: Reading; -- reading to generate on no signal
		T: Target_Choice;
	end record;

	type Input_Transition is array (Input) of Transition;
	type Transition_Table is array (State) of Input_Transition;

	type Bitlayer is tagged limited record
		-- required
		LL:               DCF77_Low_Level.LLP;
		Start_Of_Slice:   DCF77_Low_Level.Time;
		Current_State:    State;
		Buf_Ctr:          Natural;

		-- informational
		Last_Input:       Input;
		Last_Raw:         U32;
		Last_Filtered:    U32;
		Delay_Us:         DCF77_Low_Level.Time;
		Unidentified:     Natural;
		Overflown:        Natural;
	end record;

	type Coordinate is record
		X: Integer; -- For convenience use Integer here.
		Y: Integer; -- Could reduce to < 8 bit if needed...
	end record;

	type Transition_Visualization is array (State) of Coordinate;

	-- Main State Chart
	-- ----------------
	--
	-- For a drawing refer to file doc_bitlayer_statechart/blstatechart.pdf
	--
	-- The idea is as follows:
	--
	--  * Pass to next Z-state from a Z-state while the signal is low or
	--    invalid
	--  * Pass to O0 state from a Z-state when receiving the begin of a
	--    signal.
	--  * Pass to O1 state from an O0-state if the streak of 1-es is long
	--    enough to identify it as a candidate for an Bit_1 output
	--    (A corner case that still decodes to Bit_0 could also be imagined)
	--  * Pass to W2 state when a Bit_0 output was generated
	--  * Pass to W3 state when a Bit_1 output was generated. This is
	--    entering the waiting “later” compared to Bit_0 because the
	--    1-es have been longer (200ms) and thus the second has already
	--    proceeded further and we should wait shorter as to keep aligned
	--    with the beginning of the second
	--  * Pass to Wn+1 from Wn to continue waiting
	--  * Pass to Z8 from W8 in order to allow for a signal to be received
	--    earlier (W8), just in time (Z8) or later (Z9) compared to the
	--    previous signal.
	--  * Near the end (Z8/Z9/Z0) a transition may generate No_Signal
	--    rather than No_Update as to ensure that a No_Signal is output
	--    typically once per second in absence of any external signal or
	--    upon missing out on one.
	--
	-- By design, alignment is lost upon end of minute. This is a minor
	-- flaw in the design but avoids having a huge number of states to
	-- deal with.
	Transitions: constant Transition_Table := (
	--        from           action    error out   default  0      1

	S_Z0  => (I_1 | I_X1 => (A_Append, No_Update, (others => S_O10)),
		  others     => (A_Ignore, No_Update, (others => S_Z1))),
	S_Z1  => (I_1 | I_X1 => (A_Append, No_Update, (others => S_O20)),
		  others     => (A_Ignore, No_Update, (others => S_Z2))),
	S_Z2  => (I_1 | I_X1 => (A_Append, No_Update, (others => S_O30)),
		  others     => (A_Ignore, No_Update, (others => S_Z3))),
	S_Z3  => (I_1 | I_X1 => (A_Append, No_Update, (others => S_O40)),
		  others     => (A_Ignore, No_Update, (others => S_Z4))),
	S_Z4  => (I_1 | I_X1 => (A_Append, No_Update, (others => S_O50)),
		  others     => (A_Ignore, No_Update, (others => S_Z5))),
	S_Z5  => (I_1 | I_X1 => (A_Append, No_Update, (others => S_O60)),
		  others     => (A_Ignore, No_Update, (others => S_Z6))),
	S_Z6  => (I_1 | I_X1 => (A_Append, No_Update, (others => S_O70)),
		  others     => (A_Ignore, No_Update, (others => S_Z7))),
	S_Z7  => (I_1 | I_X1 => (A_Append, No_Update, (others => S_O80)),
		  others     => (A_Ignore, No_Update, (others => S_Z8))),
	S_Z8  => (I_1 | I_X1 => (A_Append, No_Update, (others => S_O90)),
		  others     => (A_Ignore, No_Update, (others => S_Z9))),
	S_Z9  => (I_1 | I_X1 => (A_Append, No_Update, (others => S_O00)),
		  others     => (A_Ignore, No_Signal, (others => S_Z0))),

	S_O10 => (I_1        => (A_Append, No_Update, (S_Z2,   S_O11, S_O11)),
		  I_0 | I_X0 => (A_Decode, No_Update, (S_Z2,   S_W2,  S_W3)),
		  others     => (A_Ignore, No_Update, (others => S_Z2))),
	S_O11 => (I_0 | I_X0 => (A_Decode, No_Update, (S_Z3,   S_W2,  S_W3)),
		  others     => (A_Ignore, No_Update, (others => S_Z3))),
	S_O20 => (I_1        => (A_Append, No_Update, (S_Z3,   S_O21, S_O21)),
		  I_0 | I_X0 => (A_Decode, No_Update, (S_Z3,   S_W2,  S_W3)),
		  others     => (A_Ignore, No_Update, (others => S_Z3))),
	S_O21 => (I_0 | I_X0 => (A_Decode, No_Update, (S_Z4,   S_W2,  S_W3)),
		  others     => (A_Ignore, No_Update, (others => S_Z4))),
	S_O30 => (I_1        => (A_Append, No_Update, (S_Z4,   S_O31, S_O31)),
		  I_0 | I_X0 => (A_Decode, No_Update, (S_Z4,   S_W2,  S_W3)),
		  others     => (A_Ignore, No_Update, (others => S_Z4))),
	S_O31 => (I_0 | I_X0 => (A_Decode, No_Update, (S_Z5,   S_W2,  S_W3)),
		  others     => (A_Ignore, No_Update, (others => S_Z5))),
	S_O40 => (I_1        => (A_Append, No_Update, (S_Z5,   S_O41, S_O41)),
		  I_0 | I_X0 => (A_Decode, No_Update, (S_Z5,   S_W2,  S_W3)),
		  others     => (A_Ignore, No_Update, (others => S_Z5))),
	S_O41 => (I_0 | I_X0 => (A_Decode, No_Update, (S_Z6,   S_W2,  S_W3)),
		  others     => (A_Ignore, No_Update, (others => S_Z6))),
	S_O50 => (I_1        => (A_Append, No_Update, (S_Z6,   S_O51, S_O51)),
		  I_0 | I_X0 => (A_Decode, No_Update, (S_Z6,   S_W2,  S_W3)),
		  others     => (A_Ignore, No_Update, (others => S_Z6))),
	S_O51 => (I_0 | I_X0 => (A_Decode, No_Update, (S_Z7,   S_W2,  S_W3)),
		  others     => (A_Ignore, No_Update, (others => S_Z7))),
	S_O60 => (I_1        => (A_Append, No_Update, (S_Z7,   S_O61, S_O61)),
		  I_0 | I_X0 => (A_Decode, No_Update, (S_Z7,   S_W2,  S_W3)),
		  others     => (A_Ignore, No_Update, (others => S_Z7))),
	S_O61 => (I_0 | I_X0 => (A_Decode, No_Update, (S_Z8,   S_W2,  S_W3)),
		  others     => (A_Ignore, No_Update, (others => S_Z8))),
	S_O70 => (I_1        => (A_Append, No_Update, (S_Z8,   S_O71, S_O71)),
		  I_0 | I_X0 => (A_Decode, No_Update, (S_Z8,   S_W2,  S_W3)),
		  others     => (A_Ignore, No_Update, (others => S_Z8))),
	S_O71 => (I_0 | I_X0 => (A_Decode, No_Update, (S_Z9,   S_W2,  S_W3)),
		  others     => (A_Ignore, No_Update, (others => S_Z9))),
	S_O80 => (I_1        => (A_Append, No_Update, (S_Z9,   S_O81, S_O81)),
		  I_0 | I_X0 => (A_Decode, No_Update, (S_Z9,   S_W2,  S_W3)),
		  others     => (A_Ignore, No_Update, (others => S_Z9))),
	S_O81 => (I_0 | I_X0 => (A_Decode, No_Signal, (S_Z0,   S_W2,  S_W3)),
		  others     => (A_Ignore, No_Signal, (others => S_Z0))),
	S_O90 => (I_1        => (A_Append, No_Signal, (S_Z0,   S_O91, S_O91)),
		  I_0 | I_X0 => (A_Decode, No_Signal, (S_Z0,   S_W2,  S_W3)),
		  others     => (A_Ignore, No_Signal, (others => S_Z0))),
	S_O91 => (I_0 | I_X0 => (A_Decode, No_Signal, (S_Z1,   S_W2,  S_W3)),
		  others     => (A_Ignore, No_Signal, (others => S_Z1))),
	S_O00 => (I_1        => (A_Append, No_Signal, (S_Z1,   S_O01, S_O01)),
		  I_0 | I_X0 => (A_Decode, No_Signal, (S_Z1,   S_W2,  S_W3)),
		  others     => (A_Ignore, No_Signal, (others => S_Z1))),
	S_O01 => (I_0 | I_X0 => (A_Decode, No_Signal, (S_Z2,   S_W2,  S_W3)),
		  others     => (A_Ignore, No_Signal, (others => S_Z2))),

	S_W2  => (others     => (A_Ignore, No_Update, (others => S_W3))),
	S_W3  => (others     => (A_Ignore, No_Update, (others => S_W4))),
	S_W4  => (others     => (A_Ignore, No_Update, (others => S_W5))),
	S_W5  => (others     => (A_Ignore, No_Update, (others => S_W6))),
	S_W6  => (others     => (A_Ignore, No_Update, (others => S_W7))),
	S_W7  => (others     => (A_Ignore, No_Update, (others => S_W8))),
	S_W8  => (others     => (A_Ignore, No_Update, (others => S_Z7)))

	); -- end Transitions

	Transition_Vis: constant Transition_Visualization := (
		S_Z0  => ( 0, 1),
		S_Z1  => ( 1, 1),
		S_Z2  => ( 2, 1),
		S_Z3  => ( 3, 1),
		S_Z4  => ( 4, 1),
		S_Z5  => ( 5, 1),
		S_Z6  => ( 6, 1),
		S_Z7  => ( 7, 1),
		S_Z8  => ( 8, 1),
		S_Z9  => ( 9, 1),

		S_O10 => ( 1, 2),
		S_O11 => ( 2, 2),
		S_O20 => ( 2, 0),
		S_O21 => ( 3, 0),
		S_O30 => ( 3, 2),
		S_O31 => ( 4, 2),
		S_O40 => ( 4, 0),
		S_O41 => ( 5, 0),
		S_O50 => ( 5, 2),
		S_O51 => ( 6, 2),
		S_O60 => ( 6, 0),
		S_O61 => ( 7, 0),
		S_O70 => ( 7, 2),
		S_O71 => ( 8, 2),
		S_O80 => ( 8, 0),
		S_O81 => ( 9, 0),
		S_O90 => ( 9, 2),
		S_O91 => (10, 2),
		S_O00 => (10, 0),
		S_O01 => (11, 0),

		S_W2  => ( 2, 3),
		S_W3  => ( 3, 3),
		S_W4  => ( 4, 3),
		S_W5  => ( 5, 3),
		S_W6  => ( 6, 3),
		S_W7  => ( 7, 3),
		S_W8  => ( 8, 3)
	);

	procedure Align_To_Slice(Ctx: in out Bitlayer);
	function Update_Main_State(Ctx: in out Bitlayer) return Reading;
	function Filter_And_Validate(IRD: in U32) return U32;
	function Next_M(Mask: in U32) return U32;
	function Analyze_And_Count(FRD: in U32; Ctr: out Natural) return Input;

end DCF77_Bitlayer;
